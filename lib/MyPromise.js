"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _PromiseState = require("./PromiseState");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// 1.1. “promise” is an object or function with a then method whose behavior conforms to the Promises/A+ specification.
var MyPromise =
/*#__PURE__*/
function () {
  function MyPromise() {
    var executor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, MyPromise);

    _defineProperty(this, "value", void 0);

    _defineProperty(this, "state", void 0);

    _defineProperty(this, "onFulfilledHandler", void 0);

    _defineProperty(this, "onRejectedHandler", void 0);

    _defineProperty(this, "promiseSettlementQueue", void 0);

    this.value = null; // default promise value as null

    this.state = _PromiseState.PromiseState.PENDING; // default promise state as pending
    // register default handlers for promise on fulfillment and rejection

    this.onFulfilledHandler = function (value) {
      return value;
    };

    this.onRejectedHandler = function (reason) {
      throw reason;
    }; // create an empty promise settlement queue for promises generated by then calls


    this.promiseSettlementQueue = []; // bind executor resolve reject callbacks

    if (executor) {
      executor(function (value) {
        /** @todo Promise Resolution Procedure */
      }, function (reason) {
        /** @todo Promise Rejection Procedure */
      });
    }
  }
  /**
   * 2.2.1 Both onFulfilled and onRejected are optional arguments:
   *
   * @param onFulfilled
   * @param onRejected
   */


  _createClass(MyPromise, [{
    key: "then",
    value: function then(onFulfilled, onRejected) {
      // create a new promise to be returned by then for promise chaining
      var promise = new MyPromise(); // 2.2.1.1 If onFulfilled is not a function, it must be ignored.

      if (typeof onFulfilled === "function") {
        promise.onFulfilledHandler = onFulfilled;
      } // 2.2.1.2 If onRejected is not a function, it must be ignored.


      if (typeof onRejected === "function") {
        promise.onFulfilledHandler = onRejected;
      }
      /**
       * 2.2.6. then may be called multiple times on the same promise.
       *   2.2.6.1. If/when promise is fulfilled, all respective onFulfilled
       *     callbacks must execute in the order of their originating calls to then.
       *   2.2.6.2. If/when promise is rejected, all respective onRejected
       *     callbacks must execute in the order of their originating calls to then.
       */


      this.promiseSettlementQueue.push(promise);
      this.processRegisteredHandlers(); // 2.2.7. then must return a promise

      return promise;
    }
    /**
     * 2.1.1. When pending, a promise:
     *   2.1.1.1. may transition to either the fulfilled or rejected state.
     * 2.1.2. When fulfilled, a promise:
     *   2.1.2.1. must not transition to any other state.
     *   2.1.2.2. must have a value, which must not change.
     * 2.1.3. When rejected, a promise:
     *   2.1.3.1. must not transition to any other state.
     *   2.1.3.2. must have a reason, which must not change.
     *
     * @param state state to transition to
     * @param value value passed with the transition for
     */

  }, {
    key: "transitionState",
    value: function transitionState(state, value) {
      if (this.state === state || this.state !== _PromiseState.PromiseState.PENDING) {
        // if the current state is same as the state being transitioned to
        // or the promise is not currently in pending state
        // do nothing
        return;
      }

      this.value = value;
      this.state = state;
      this.processRegisteredHandlers();
    }
  }, {
    key: "processRegisteredHandlers",
    value: function processRegisteredHandlers() {
      var _this = this;

      if (this.state !== _PromiseState.PromiseState.PENDING) {
        // 2.2.4 onFulfilled or onRejected must not be called
        // until the execution context stack contains only platform code.
        setTimeout(function () {
          // 2.2.7. then may be called multiple times on the same promise.
          //   2.2.6.1. If/when promise is fulfilled,
          //     all respective onFulfilled callbacks must execute in the
          //     order of their originating calls to then.
          //   2.2.6.2. If/when promise is rejected,
          //     all respective onRejected callbacks must execute in the
          //     order of their originating calls to then.
          // this is acheived by dequeue on FIFO data structure (i.e. queue)
          while (_this.promiseSettlementQueue.length) {
            // dequeue
            var promise = _this.promiseSettlementQueue.shift();

            try {
              // 2.2.5. onFulfilled and onRejected must be called as functions (i.e. with no this value).
              var value = (_this.state === _PromiseState.PromiseState.FULFILLED ? promise.onFulfilled : promise.onRejected)(_this.value); // 2.2.7.1. If either onFulfilled or onRejected returns a value x,
              // run the Promise Resolution Procedure [[Resolve]](promise2, x).

              /** @todo Promise Resolution Procedure */
            } catch (e) {// 2.2.7.2. If either onFulfilled or onRejected throws an exception e,
              // promise2 must be rejected with e as the reason.

              /** @todo Promise Rejection Procedure */
            }
          }
        }, 0);
      }
    }
  }]);

  return MyPromise;
}();

exports.default = MyPromise;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NeVByb21pc2UudHMiXSwibmFtZXMiOlsiTXlQcm9taXNlIiwiZXhlY3V0b3IiLCJ2YWx1ZSIsInN0YXRlIiwiUHJvbWlzZVN0YXRlIiwiUEVORElORyIsIm9uRnVsZmlsbGVkSGFuZGxlciIsIm9uUmVqZWN0ZWRIYW5kbGVyIiwicmVhc29uIiwicHJvbWlzZVNldHRsZW1lbnRRdWV1ZSIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsInByb21pc2UiLCJwdXNoIiwicHJvY2Vzc1JlZ2lzdGVyZWRIYW5kbGVycyIsInNldFRpbWVvdXQiLCJsZW5ndGgiLCJzaGlmdCIsIkZVTEZJTExFRCIsImUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7QUFHQTtJQUNxQkEsUzs7O0FBVW5CLHVCQUFtRDtBQUFBLFFBQXZDQyxRQUF1Qyx1RUFBTixJQUFNOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUNqRCxTQUFLQyxLQUFMLEdBQWEsSUFBYixDQURpRCxDQUM5Qjs7QUFDbkIsU0FBS0MsS0FBTCxHQUFhQywyQkFBYUMsT0FBMUIsQ0FGaUQsQ0FFZDtBQUVuQzs7QUFDQSxTQUFLQyxrQkFBTCxHQUEwQixVQUFDSixLQUFEO0FBQUEsYUFBZ0JBLEtBQWhCO0FBQUEsS0FBMUI7O0FBQ0EsU0FBS0ssaUJBQUwsR0FBeUIsVUFBQ0MsTUFBRCxFQUF1QjtBQUFFLFlBQU1BLE1BQU47QUFBZSxLQUFqRSxDQU5pRCxDQVFqRDs7O0FBQ0EsU0FBS0Msc0JBQUwsR0FBOEIsRUFBOUIsQ0FUaUQsQ0FXakQ7O0FBQ0EsUUFBSVIsUUFBSixFQUFjO0FBQ1pBLE1BQUFBLFFBQVEsQ0FBQyxVQUFDQyxLQUFELEVBQWdCO0FBQ3ZCO0FBQ0QsT0FGTyxFQUVMLFVBQUNNLE1BQUQsRUFBaUI7QUFDbEI7QUFDRCxPQUpPLENBQVI7QUFLRDtBQUNGO0FBRUQ7Ozs7Ozs7Ozs7eUJBTVlFLFcsRUFBa0JDLFUsRUFBNEI7QUFDeEQ7QUFDQSxVQUFNQyxPQUFrQixHQUFHLElBQUlaLFNBQUosRUFBM0IsQ0FGd0QsQ0FJeEQ7O0FBQ0EsVUFBSSxPQUFPVSxXQUFQLEtBQXVCLFVBQTNCLEVBQXVDO0FBQ3JDRSxRQUFBQSxPQUFPLENBQUNOLGtCQUFSLEdBQTZCSSxXQUE3QjtBQUNELE9BUHVELENBU3hEOzs7QUFDQSxVQUFJLE9BQU9DLFVBQVAsS0FBc0IsVUFBMUIsRUFBc0M7QUFDcENDLFFBQUFBLE9BQU8sQ0FBQ04sa0JBQVIsR0FBNkJLLFVBQTdCO0FBQ0Q7QUFFRDs7Ozs7Ozs7O0FBT0EsV0FBS0Ysc0JBQUwsQ0FBNEJJLElBQTVCLENBQWlDRCxPQUFqQztBQUNBLFdBQUtFLHlCQUFMLEdBdEJ3RCxDQXdCeEQ7O0FBQ0EsYUFBT0YsT0FBUDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7b0NBYXVCVCxLLEVBQXFCRCxLLEVBQWtCO0FBRTVELFVBQUksS0FBS0MsS0FBTCxLQUFlQSxLQUFmLElBQXdCLEtBQUtBLEtBQUwsS0FBZUMsMkJBQWFDLE9BQXhELEVBQWlFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQsV0FBS0gsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsV0FBS0MsS0FBTCxHQUFhQSxLQUFiO0FBRUEsV0FBS1cseUJBQUw7QUFDRDs7O2dEQUV5QztBQUFBOztBQUN4QyxVQUFJLEtBQUtYLEtBQUwsS0FBZUMsMkJBQWFDLE9BQWhDLEVBQXlDO0FBQ3ZDO0FBQ0E7QUFDQVUsUUFBQUEsVUFBVSxDQUFDLFlBQU07QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQU8sS0FBSSxDQUFDTixzQkFBTCxDQUE0Qk8sTUFBbkMsRUFBMkM7QUFDekM7QUFDQSxnQkFBTUosT0FBc0IsR0FBRyxLQUFJLENBQUNILHNCQUFMLENBQTRCUSxLQUE1QixFQUEvQjs7QUFFQSxnQkFBSTtBQUNGO0FBQ0Esa0JBQU1mLEtBQUssR0FBRyxDQUNaLEtBQUksQ0FBQ0MsS0FBTCxLQUFlQywyQkFBYWMsU0FBNUIsR0FBd0NOLE9BQU8sQ0FBQ0YsV0FBaEQsR0FBOERFLE9BQU8sQ0FBQ0QsVUFEMUQsRUFFWixLQUFJLENBQUNULEtBRk8sQ0FBZCxDQUZFLENBS0Y7QUFDQTs7QUFDQTtBQUNELGFBUkQsQ0FRRSxPQUFPaUIsQ0FBUCxFQUFVLENBQ1Y7QUFDQTs7QUFDQTtBQUNEO0FBQ0Y7QUFDRixTQTVCUyxFQTRCUCxDQTVCTyxDQUFWO0FBNkJEO0FBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgUHJvbWlzZVN0YXRlIH0gZnJvbSBcIi4vUHJvbWlzZVN0YXRlXCI7XG5pbXBvcnQgVGhlbmFibGUgZnJvbSBcIi4vVGhlbmFibGVcIjtcblxuLy8gMS4xLiDigJxwcm9taXNl4oCdIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgdGhlbiBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhlIFByb21pc2VzL0ErIHNwZWNpZmljYXRpb24uXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNeVByb21pc2UgaW1wbGVtZW50cyBUaGVuYWJsZSB7XG5cbiAgcHJpdmF0ZSB2YWx1ZTogYW55O1xuICBwcml2YXRlIHN0YXRlOiBQcm9taXNlU3RhdGU7XG5cbiAgcHJpdmF0ZSBvbkZ1bGZpbGxlZEhhbmRsZXI6IENhbGxhYmxlRnVuY3Rpb247XG4gIHByaXZhdGUgb25SZWplY3RlZEhhbmRsZXI6IENhbGxhYmxlRnVuY3Rpb247XG5cbiAgcHJpdmF0ZSBwcm9taXNlU2V0dGxlbWVudFF1ZXVlOiBNeVByb21pc2VbXTtcblxuICBjb25zdHJ1Y3RvcihleGVjdXRvcjogQ2FsbGFibGVGdW5jdGlvbnxhbnkgPSBudWxsKSB7XG4gICAgdGhpcy52YWx1ZSA9IG51bGw7IC8vIGRlZmF1bHQgcHJvbWlzZSB2YWx1ZSBhcyBudWxsXG4gICAgdGhpcy5zdGF0ZSA9IFByb21pc2VTdGF0ZS5QRU5ESU5HOyAvLyBkZWZhdWx0IHByb21pc2Ugc3RhdGUgYXMgcGVuZGluZ1xuXG4gICAgLy8gcmVnaXN0ZXIgZGVmYXVsdCBoYW5kbGVycyBmb3IgcHJvbWlzZSBvbiBmdWxmaWxsbWVudCBhbmQgcmVqZWN0aW9uXG4gICAgdGhpcy5vbkZ1bGZpbGxlZEhhbmRsZXIgPSAodmFsdWU6IGFueSkgPT4gdmFsdWU7XG4gICAgdGhpcy5vblJlamVjdGVkSGFuZGxlciA9IChyZWFzb246IEVycm9yfGFueSkgPT4geyB0aHJvdyByZWFzb247IH07XG5cbiAgICAvLyBjcmVhdGUgYW4gZW1wdHkgcHJvbWlzZSBzZXR0bGVtZW50IHF1ZXVlIGZvciBwcm9taXNlcyBnZW5lcmF0ZWQgYnkgdGhlbiBjYWxsc1xuICAgIHRoaXMucHJvbWlzZVNldHRsZW1lbnRRdWV1ZSA9IFtdO1xuXG4gICAgLy8gYmluZCBleGVjdXRvciByZXNvbHZlIHJlamVjdCBjYWxsYmFja3NcbiAgICBpZiAoZXhlY3V0b3IpIHtcbiAgICAgIGV4ZWN1dG9yKCh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgIC8qKiBAdG9kbyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlICovXG4gICAgICB9LCAocmVhc29uOiBhbnkpID0+IHtcbiAgICAgICAgLyoqIEB0b2RvIFByb21pc2UgUmVqZWN0aW9uIFByb2NlZHVyZSAqL1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIDIuMi4xIEJvdGggb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9wdGlvbmFsIGFyZ3VtZW50czpcbiAgICpcbiAgICogQHBhcmFtIG9uRnVsZmlsbGVkXG4gICAqIEBwYXJhbSBvblJlamVjdGVkXG4gICAqL1xuICBwdWJsaWMgdGhlbihvbkZ1bGZpbGxlZDogYW55LCBvblJlamVjdGVkOiBhbnkpOiBNeVByb21pc2Uge1xuICAgIC8vIGNyZWF0ZSBhIG5ldyBwcm9taXNlIHRvIGJlIHJldHVybmVkIGJ5IHRoZW4gZm9yIHByb21pc2UgY2hhaW5pbmdcbiAgICBjb25zdCBwcm9taXNlOiBNeVByb21pc2UgPSBuZXcgTXlQcm9taXNlKCk7XG5cbiAgICAvLyAyLjIuMS4xIElmIG9uRnVsZmlsbGVkIGlzIG5vdCBhIGZ1bmN0aW9uLCBpdCBtdXN0IGJlIGlnbm9yZWQuXG4gICAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBwcm9taXNlLm9uRnVsZmlsbGVkSGFuZGxlciA9IG9uRnVsZmlsbGVkO1xuICAgIH1cblxuICAgIC8vIDIuMi4xLjIgSWYgb25SZWplY3RlZCBpcyBub3QgYSBmdW5jdGlvbiwgaXQgbXVzdCBiZSBpZ25vcmVkLlxuICAgIGlmICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBwcm9taXNlLm9uRnVsZmlsbGVkSGFuZGxlciA9IG9uUmVqZWN0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogMi4yLjYuIHRoZW4gbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBwcm9taXNlLlxuICAgICAqICAgMi4yLjYuMS4gSWYvd2hlbiBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYWxsIHJlc3BlY3RpdmUgb25GdWxmaWxsZWRcbiAgICAgKiAgICAgY2FsbGJhY2tzIG11c3QgZXhlY3V0ZSBpbiB0aGUgb3JkZXIgb2YgdGhlaXIgb3JpZ2luYXRpbmcgY2FsbHMgdG8gdGhlbi5cbiAgICAgKiAgIDIuMi42LjIuIElmL3doZW4gcHJvbWlzZSBpcyByZWplY3RlZCwgYWxsIHJlc3BlY3RpdmUgb25SZWplY3RlZFxuICAgICAqICAgICBjYWxsYmFja3MgbXVzdCBleGVjdXRlIGluIHRoZSBvcmRlciBvZiB0aGVpciBvcmlnaW5hdGluZyBjYWxscyB0byB0aGVuLlxuICAgICAqL1xuICAgIHRoaXMucHJvbWlzZVNldHRsZW1lbnRRdWV1ZS5wdXNoKHByb21pc2UpO1xuICAgIHRoaXMucHJvY2Vzc1JlZ2lzdGVyZWRIYW5kbGVycygpO1xuXG4gICAgLy8gMi4yLjcuIHRoZW4gbXVzdCByZXR1cm4gYSBwcm9taXNlXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogMi4xLjEuIFdoZW4gcGVuZGluZywgYSBwcm9taXNlOlxuICAgKiAgIDIuMS4xLjEuIG1heSB0cmFuc2l0aW9uIHRvIGVpdGhlciB0aGUgZnVsZmlsbGVkIG9yIHJlamVjdGVkIHN0YXRlLlxuICAgKiAyLjEuMi4gV2hlbiBmdWxmaWxsZWQsIGEgcHJvbWlzZTpcbiAgICogICAyLjEuMi4xLiBtdXN0IG5vdCB0cmFuc2l0aW9uIHRvIGFueSBvdGhlciBzdGF0ZS5cbiAgICogICAyLjEuMi4yLiBtdXN0IGhhdmUgYSB2YWx1ZSwgd2hpY2ggbXVzdCBub3QgY2hhbmdlLlxuICAgKiAyLjEuMy4gV2hlbiByZWplY3RlZCwgYSBwcm9taXNlOlxuICAgKiAgIDIuMS4zLjEuIG11c3Qgbm90IHRyYW5zaXRpb24gdG8gYW55IG90aGVyIHN0YXRlLlxuICAgKiAgIDIuMS4zLjIuIG11c3QgaGF2ZSBhIHJlYXNvbiwgd2hpY2ggbXVzdCBub3QgY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0gc3RhdGUgc3RhdGUgdG8gdHJhbnNpdGlvbiB0b1xuICAgKiBAcGFyYW0gdmFsdWUgdmFsdWUgcGFzc2VkIHdpdGggdGhlIHRyYW5zaXRpb24gZm9yXG4gICAqL1xuICBwdWJsaWMgdHJhbnNpdGlvblN0YXRlKHN0YXRlOiBQcm9taXNlU3RhdGUsIHZhbHVlOiBhbnkpOiB2b2lkIHtcblxuICAgIGlmICh0aGlzLnN0YXRlID09PSBzdGF0ZSB8fCB0aGlzLnN0YXRlICE9PSBQcm9taXNlU3RhdGUuUEVORElORykge1xuICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgc2FtZSBhcyB0aGUgc3RhdGUgYmVpbmcgdHJhbnNpdGlvbmVkIHRvXG4gICAgICAvLyBvciB0aGUgcHJvbWlzZSBpcyBub3QgY3VycmVudGx5IGluIHBlbmRpbmcgc3RhdGVcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgdGhpcy5wcm9jZXNzUmVnaXN0ZXJlZEhhbmRsZXJzKCk7XG4gIH1cblxuICBwcml2YXRlIHByb2Nlc3NSZWdpc3RlcmVkSGFuZGxlcnMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFByb21pc2VTdGF0ZS5QRU5ESU5HKSB7XG4gICAgICAvLyAyLjIuNCBvbkZ1bGZpbGxlZCBvciBvblJlamVjdGVkIG11c3Qgbm90IGJlIGNhbGxlZFxuICAgICAgLy8gdW50aWwgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IHN0YWNrIGNvbnRhaW5zIG9ubHkgcGxhdGZvcm0gY29kZS5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuXG4gICAgICAgIC8vIDIuMi43LiB0aGVuIG1heSBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWUgcHJvbWlzZS5cbiAgICAgICAgLy8gICAyLjIuNi4xLiBJZi93aGVuIHByb21pc2UgaXMgZnVsZmlsbGVkLFxuICAgICAgICAvLyAgICAgYWxsIHJlc3BlY3RpdmUgb25GdWxmaWxsZWQgY2FsbGJhY2tzIG11c3QgZXhlY3V0ZSBpbiB0aGVcbiAgICAgICAgLy8gICAgIG9yZGVyIG9mIHRoZWlyIG9yaWdpbmF0aW5nIGNhbGxzIHRvIHRoZW4uXG4gICAgICAgIC8vICAgMi4yLjYuMi4gSWYvd2hlbiBwcm9taXNlIGlzIHJlamVjdGVkLFxuICAgICAgICAvLyAgICAgYWxsIHJlc3BlY3RpdmUgb25SZWplY3RlZCBjYWxsYmFja3MgbXVzdCBleGVjdXRlIGluIHRoZVxuICAgICAgICAvLyAgICAgb3JkZXIgb2YgdGhlaXIgb3JpZ2luYXRpbmcgY2FsbHMgdG8gdGhlbi5cbiAgICAgICAgLy8gdGhpcyBpcyBhY2hlaXZlZCBieSBkZXF1ZXVlIG9uIEZJRk8gZGF0YSBzdHJ1Y3R1cmUgKGkuZS4gcXVldWUpXG4gICAgICAgIHdoaWxlICh0aGlzLnByb21pc2VTZXR0bGVtZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gZGVxdWV1ZVxuICAgICAgICAgIGNvbnN0IHByb21pc2U6IE15UHJvbWlzZXxhbnkgPSB0aGlzLnByb21pc2VTZXR0bGVtZW50UXVldWUuc2hpZnQoKTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyAyLjIuNS4gb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgbXVzdCBiZSBjYWxsZWQgYXMgZnVuY3Rpb25zIChpLmUuIHdpdGggbm8gdGhpcyB2YWx1ZSkuXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IChcbiAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gUHJvbWlzZVN0YXRlLkZVTEZJTExFRCA/IHByb21pc2Uub25GdWxmaWxsZWQgOiBwcm9taXNlLm9uUmVqZWN0ZWRcbiAgICAgICAgICAgICkodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAvLyAyLjIuNy4xLiBJZiBlaXRoZXIgb25GdWxmaWxsZWQgb3Igb25SZWplY3RlZCByZXR1cm5zIGEgdmFsdWUgeCxcbiAgICAgICAgICAgIC8vIHJ1biB0aGUgUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZSBbW1Jlc29sdmVdXShwcm9taXNlMiwgeCkuXG4gICAgICAgICAgICAvKiogQHRvZG8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZSAqL1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIDIuMi43LjIuIElmIGVpdGhlciBvbkZ1bGZpbGxlZCBvciBvblJlamVjdGVkIHRocm93cyBhbiBleGNlcHRpb24gZSxcbiAgICAgICAgICAgIC8vIHByb21pc2UyIG11c3QgYmUgcmVqZWN0ZWQgd2l0aCBlIGFzIHRoZSByZWFzb24uXG4gICAgICAgICAgICAvKiogQHRvZG8gUHJvbWlzZSBSZWplY3Rpb24gUHJvY2VkdXJlICovXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==