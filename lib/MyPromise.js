"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _PromiseResolutionProcedure = _interopRequireDefault(require("./PromiseResolutionProcedure"));

var _PromiseState = require("./PromiseState");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// 1.1. “promise” is an object or function with a then method whose behavior conforms to the Promises/A+ specification.
var MyPromise =
/*#__PURE__*/
function () {
  _createClass(MyPromise, [{
    key: "state",
    // instance variables
    // getters & setters
    get: function get() {
      return this.STATE;
    }
  }, {
    key: "value",
    get: function get() {
      return this.VALUE;
    }
  }]);

  function MyPromise() {
    var _this = this;

    var executor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, MyPromise);

    _defineProperty(this, "VALUE", void 0);

    _defineProperty(this, "STATE", void 0);

    _defineProperty(this, "onFulfilled", void 0);

    _defineProperty(this, "onRejected", void 0);

    _defineProperty(this, "promiseSettlementQueue", void 0);

    this.VALUE = null; // default promise value as null

    this.STATE = _PromiseState.PromiseState.PENDING; // default promise state as pending
    // register default handlers for promise on fulfillment and rejection

    this.onFulfilled = function (value) {
      return value;
    };

    this.onRejected = function (reason) {
      throw reason;
    }; // create an empty promise settlement queue for promises generated by then calls


    this.promiseSettlementQueue = []; // bind executor resolve reject callbacks

    if (executor) {
      executor(function (value) {
        _PromiseResolutionProcedure.default.resolve(_this, value);
      }, function (reason) {
        _this.reject(reason);
      });
    }
  }
  /**
   * 2.2.1 Both onFulfilled and onRejected are optional arguments:
   *
   * @param onFulfilled
   * @param onRejected
   */


  _createClass(MyPromise, [{
    key: "then",
    value: function then(onFulfilled, onRejected) {
      // create a new promise to be returned by then for promise chaining
      var promise = new MyPromise(); // 2.2.1.1 If onFulfilled is not a function, it must be ignored.

      if (typeof onFulfilled === "function") {
        promise.onFulfilled = onFulfilled;
      } // 2.2.1.2 If onRejected is not a function, it must be ignored.


      if (typeof onRejected === "function") {
        promise.onRejected = onRejected;
      }
      /**
       * 2.2.6. then may be called multiple times on the same promise.
       *   2.2.6.1. If/when promise is fulfilled, all respective onFulfilled
       *     callbacks must execute in the order of their originating calls to then.
       *   2.2.6.2. If/when promise is rejected, all respective onRejected
       *     callbacks must execute in the order of their originating calls to then.
       */


      this.promiseSettlementQueue.push(promise);
      this.processRegisteredHandlers(); // 2.2.7. then must return a promise

      return promise;
    }
    /**
     * Neater promise chaining
     * @param onRejected Takes only onRejected callback
     */

  }, {
    key: "catch",
    value: function _catch(onRejected) {
      return this.then(null, onRejected);
    }
    /**
     * 2.1.1. When pending, a promise:
     *   2.1.1.1. may transition to either the fulfilled or rejected state.
     * 2.1.2. When fulfilled, a promise:
     *   2.1.2.1. must not transition to any other state.
     *   2.1.2.2. must have a value, which must not change.
     * 2.1.3. When rejected, a promise:
     *   2.1.3.1. must not transition to any other state.
     *   2.1.3.2. must have a reason, which must not change.
     *
     * @param state state to transition to
     * @param value value passed with the transition for
     */

  }, {
    key: "transitionState",
    value: function transitionState(state, value) {
      if (this.STATE === state || this.STATE !== _PromiseState.PromiseState.PENDING) {
        // if the current state is same as the state being transitioned to
        // or the promise is not currently in pending state
        // do nothing
        return;
      }

      this.VALUE = value;
      this.STATE = state;
      this.processRegisteredHandlers();
    }
    /**
     * fulfill
     * @param value any value
     */

  }, {
    key: "fulfill",
    value: function fulfill(value) {
      this.transitionState(_PromiseState.PromiseState.FULFILLED, value);
    }
    /**
     * reject
     * @param reason can by anything but generally an instance of Error object
     */

  }, {
    key: "reject",
    value: function reject(reason) {
      this.transitionState(_PromiseState.PromiseState.REJECTED, reason);
    }
    /**
     * tries to adopt state of supplied promise
     * @param x Promise object, whose state the current promise instance will adopt
     */

  }, {
    key: "adoptStateOf",
    value: function adoptStateOf(x) {
      this.transitionState(x.state, x.value);
    }
  }, {
    key: "processRegisteredHandlers",
    value: function processRegisteredHandlers() {
      var _this2 = this;

      if (this.STATE !== _PromiseState.PromiseState.PENDING) {
        // 2.2.4 onFulfilled or onRejected must not be called
        // until the execution context stack contains only platform code.
        setTimeout(function () {
          // 2.2.7. then may be called multiple times on the same promise.
          //   2.2.6.1. If/when promise is fulfilled,
          //     all respective onFulfilled callbacks must execute in the
          //     order of their originating calls to then.
          //   2.2.6.2. If/when promise is rejected,
          //     all respective onRejected callbacks must execute in the
          //     order of their originating calls to then.
          // this is acheived by dequeue on FIFO data structure (i.e. queue)
          while (_this2.promiseSettlementQueue.length) {
            // dequeue
            var promise = _this2.promiseSettlementQueue.shift();

            try {
              // 2.2.5. onFulfilled and onRejected must be called as functions (i.e. with no this value).
              var value = (_this2.STATE === _PromiseState.PromiseState.FULFILLED ? promise.onFulfilled : promise.onRejected)(_this2.VALUE); // 2.2.7.1. If either onFulfilled or onRejected returns a value x,
              // run the Promise Resolution Procedure [[Resolve]](promise2, x).

              _PromiseResolutionProcedure.default.resolve(promise, value);
            } catch (e) {
              // 2.2.7.2. If either onFulfilled or onRejected throws an exception e,
              // promise2 must be rejected with e as the reason.
              promise.reject(e);
            }
          }
        }, 0);
      }
    }
  }]);

  return MyPromise;
}();

exports.default = MyPromise;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NeVByb21pc2UudHMiXSwibmFtZXMiOlsiTXlQcm9taXNlIiwiU1RBVEUiLCJWQUxVRSIsImV4ZWN1dG9yIiwiUHJvbWlzZVN0YXRlIiwiUEVORElORyIsIm9uRnVsZmlsbGVkIiwidmFsdWUiLCJvblJlamVjdGVkIiwicmVhc29uIiwicHJvbWlzZVNldHRsZW1lbnRRdWV1ZSIsIlByb21pc2VSZXNvbHV0aW9uUHJvY2VkdXJlIiwicmVzb2x2ZSIsInJlamVjdCIsInByb21pc2UiLCJwdXNoIiwicHJvY2Vzc1JlZ2lzdGVyZWRIYW5kbGVycyIsInRoZW4iLCJzdGF0ZSIsInRyYW5zaXRpb25TdGF0ZSIsIkZVTEZJTExFRCIsIlJFSkVDVEVEIiwieCIsInNldFRpbWVvdXQiLCJsZW5ndGgiLCJzaGlmdCIsImUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBR0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUdBO0lBQ3FCQSxTOzs7OztBQUVuQjtBQVVBO3dCQUUwQjtBQUN4QixhQUFPLEtBQUtDLEtBQVo7QUFDRDs7O3dCQUVnQjtBQUNmLGFBQU8sS0FBS0MsS0FBWjtBQUNEOzs7QUFFRCx1QkFBbUQ7QUFBQTs7QUFBQSxRQUF2Q0MsUUFBdUMsdUVBQU4sSUFBTTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFDakQsU0FBS0QsS0FBTCxHQUFhLElBQWIsQ0FEaUQsQ0FDOUI7O0FBQ25CLFNBQUtELEtBQUwsR0FBYUcsMkJBQWFDLE9BQTFCLENBRmlELENBRWQ7QUFFbkM7O0FBQ0EsU0FBS0MsV0FBTCxHQUFtQixVQUFDQyxLQUFEO0FBQUEsYUFBZ0JBLEtBQWhCO0FBQUEsS0FBbkI7O0FBQ0EsU0FBS0MsVUFBTCxHQUFrQixVQUFDQyxNQUFELEVBQXVCO0FBQUUsWUFBTUEsTUFBTjtBQUFlLEtBQTFELENBTmlELENBUWpEOzs7QUFDQSxTQUFLQyxzQkFBTCxHQUE4QixFQUE5QixDQVRpRCxDQVdqRDs7QUFDQSxRQUFJUCxRQUFK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ZnJvbSBcIi4vQ2F0Y2hhYmxlXCI7XG5pbXBvcnQgUHJvbWlzZVJlc29sdXRpb25Qcm9jZWR1cmUgZnJvbSBcIi4vUHJvbWlzZVJlc29sdXRpb25Qcm9jZWR1cmVcIjtcbmltcG9ydCB7IFByb21pc2VTdGF0ZSB9IGZyb20gXCIuL1Byb21pc2VTdGF0ZVwiO1xuaW1wb3J0IFRoZW5hYmxlIGZyb20gXCIuL1RoZW5hYmxlXCI7XG5cbi8vIDEuMS4g4oCccHJvbWlzZeKAnSBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIHRoZW4gbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoZSBQcm9taXNlcy9BKyBzcGVjaWZpY2F0aW9uLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTXlQcm9taXNlIGltcGxlbWVudHMgVGhlbmFibGUsIENhdGNoYWJsZSB7XG5cbiAgLy8gaW5zdGFuY2UgdmFyaWFibGVzXG5cbiAgcHJpdmF0ZSBWQUxVRTogYW55O1xuICBwcml2YXRlIFNUQVRFOiBQcm9taXNlU3RhdGU7XG5cbiAgcHJpdmF0ZSBvbkZ1bGZpbGxlZDogQ2FsbGFibGVGdW5jdGlvbjtcbiAgcHJpdmF0ZSBvblJlamVjdGVkOiBDYWxsYWJsZUZ1bmN0aW9uO1xuXG4gIHByaXZhdGUgcHJvbWlzZVNldHRsZW1lbnRRdWV1ZTogTXlQcm9taXNlW107XG5cbiAgLy8gZ2V0dGVycyAmIHNldHRlcnNcblxuICBnZXQgc3RhdGUoKTogUHJvbWlzZVN0YXRlIHtcbiAgICByZXR1cm4gdGhpcy5TVEFURTtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLlZBTFVFO1xuICB9XG5cbiAgY29uc3RydWN0b3IoZXhlY3V0b3I6IENhbGxhYmxlRnVuY3Rpb258YW55ID0gbnVsbCkge1xuICAgIHRoaXMuVkFMVUUgPSBudWxsOyAvLyBkZWZhdWx0IHByb21pc2UgdmFsdWUgYXMgbnVsbFxuICAgIHRoaXMuU1RBVEUgPSBQcm9taXNlU3RhdGUuUEVORElORzsgLy8gZGVmYXVsdCBwcm9taXNlIHN0YXRlIGFzIHBlbmRpbmdcblxuICAgIC8vIHJlZ2lzdGVyIGRlZmF1bHQgaGFuZGxlcnMgZm9yIHByb21pc2Ugb24gZnVsZmlsbG1lbnQgYW5kIHJlamVjdGlvblxuICAgIHRoaXMub25GdWxmaWxsZWQgPSAodmFsdWU6IGFueSkgPT4gdmFsdWU7XG4gICAgdGhpcy5vblJlamVjdGVkID0gKHJlYXNvbjogRXJyb3J8YW55KSA9PiB7IHRocm93IHJlYXNvbjsgfTtcblxuICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBwcm9taXNlIHNldHRsZW1lbnQgcXVldWUgZm9yIHByb21pc2VzIGdlbmVyYXRlZCBieSB0aGVuIGNhbGxzXG4gICAgdGhpcy5wcm9taXNlU2V0dGxlbWVudFF1ZXVlID0gW107XG5cbiAgICAvLyBiaW5kIGV4ZWN1dG9yIHJlc29sdmUgcmVqZWN0IGNhbGxiYWNrc1xuICAgIGlmIChleGVjdXRvcikge1xuICAgICAgZXhlY3V0b3IoKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgUHJvbWlzZVJlc29sdXRpb25Qcm9jZWR1cmUucmVzb2x2ZSh0aGlzLCB2YWx1ZSk7XG4gICAgICB9LCAocmVhc29uOiBhbnkpID0+IHtcbiAgICAgICAgdGhpcy5yZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAyLjIuMSBCb3RoIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvcHRpb25hbCBhcmd1bWVudHM6XG4gICAqXG4gICAqIEBwYXJhbSBvbkZ1bGZpbGxlZFxuICAgKiBAcGFyYW0gb25SZWplY3RlZFxuICAgKi9cbiAgcHVibGljIHRoZW4ob25GdWxmaWxsZWQ/OiBhbnksIG9uUmVqZWN0ZWQ/OiBhbnkpOiBNeVByb21pc2Uge1xuICAgIC8vIGNyZWF0ZSBhIG5ldyBwcm9taXNlIHRvIGJlIHJldHVybmVkIGJ5IHRoZW4gZm9yIHByb21pc2UgY2hhaW5pbmdcbiAgICBjb25zdCBwcm9taXNlOiBNeVByb21pc2UgPSBuZXcgTXlQcm9taXNlKCk7XG5cbiAgICAvLyAyLjIuMS4xIElmIG9uRnVsZmlsbGVkIGlzIG5vdCBhIGZ1bmN0aW9uLCBpdCBtdXN0IGJlIGlnbm9yZWQuXG4gICAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBwcm9taXNlLm9uRnVsZmlsbGVkID0gb25GdWxmaWxsZWQ7XG4gICAgfVxuXG4gICAgLy8gMi4yLjEuMiBJZiBvblJlamVjdGVkIGlzIG5vdCBhIGZ1bmN0aW9uLCBpdCBtdXN0IGJlIGlnbm9yZWQuXG4gICAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHByb21pc2Uub25SZWplY3RlZCA9IG9uUmVqZWN0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogMi4yLjYuIHRoZW4gbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBwcm9taXNlLlxuICAgICAqICAgMi4yLjYuMS4gSWYvd2hlbiBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgYWxsIHJlc3BlY3RpdmUgb25GdWxmaWxsZWRcbiAgICAgKiAgICAgY2FsbGJhY2tzIG11c3QgZXhlY3V0ZSBpbiB0aGUgb3JkZXIgb2YgdGhlaXIgb3JpZ2luYXRpbmcgY2FsbHMgdG8gdGhlbi5cbiAgICAgKiAgIDIuMi42LjIuIElmL3doZW4gcHJvbWlzZSBpcyByZWplY3RlZCwgYWxsIHJlc3BlY3RpdmUgb25SZWplY3RlZFxuICAgICAqICAgICBjYWxsYmFja3MgbXVzdCBleGVjdXRlIGluIHRoZSBvcmRlciBvZiB0aGVpciBvcmlnaW5hdGluZyBjYWxscyB0byB0aGVuLlxuICAgICAqL1xuICAgIHRoaXMucHJvbWlzZVNldHRsZW1lbnRRdWV1ZS5wdXNoKHByb21pc2UpO1xuICAgIHRoaXMucHJvY2Vzc1JlZ2lzdGVyZWRIYW5kbGVycygpO1xuXG4gICAgLy8gMi4yLjcuIHRoZW4gbXVzdCByZXR1cm4gYSBwcm9taXNlXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogTmVhdGVyIHByb21pc2UgY2hhaW5pbmdcbiAgICogQHBhcmFtIG9uUmVqZWN0ZWQgVGFrZXMgb25seSBvblJlamVjdGVkIGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgY2F0Y2gob25SZWplY3RlZDogYW55KTogTXlQcm9taXNlIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIDIuMS4xLiBXaGVuIHBlbmRpbmcsIGEgcHJvbWlzZTpcbiAgICogICAyLjEuMS4xLiBtYXkgdHJhbnNpdGlvbiB0byBlaXRoZXIgdGhlIGZ1bGZpbGxlZCBvciByZWplY3RlZCBzdGF0ZS5cbiAgICogMi4xLjIuIFdoZW4gZnVsZmlsbGVkLCBhIHByb21pc2U6XG4gICAqICAgMi4xLjIuMS4gbXVzdCBub3QgdHJhbnNpdGlvbiB0byBhbnkgb3RoZXIgc3RhdGUuXG4gICAqICAgMi4xLjIuMi4gbXVzdCBoYXZlIGEgdmFsdWUsIHdoaWNoIG11c3Qgbm90IGNoYW5nZS5cbiAgICogMi4xLjMuIFdoZW4gcmVqZWN0ZWQsIGEgcHJvbWlzZTpcbiAgICogICAyLjEuMy4xLiBtdXN0IG5vdCB0cmFuc2l0aW9uIHRvIGFueSBvdGhlciBzdGF0ZS5cbiAgICogICAyLjEuMy4yLiBtdXN0IGhhdmUgYSByZWFzb24sIHdoaWNoIG11c3Qgbm90IGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG9cbiAgICogQHBhcmFtIHZhbHVlIHZhbHVlIHBhc3NlZCB3aXRoIHRoZSB0cmFuc2l0aW9uIGZvclxuICAgKi9cbiAgcHVibGljIHRyYW5zaXRpb25TdGF0ZShzdGF0ZTogUHJvbWlzZVN0YXRlLCB2YWx1ZTogYW55KTogdm9pZCB7XG5cbiAgICBpZiAodGhpcy5TVEFURSA9PT0gc3RhdGUgfHwgdGhpcy5TVEFURSAhPT0gUHJvbWlzZVN0YXRlLlBFTkRJTkcpIHtcbiAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHNhbWUgYXMgdGhlIHN0YXRlIGJlaW5nIHRyYW5zaXRpb25lZCB0b1xuICAgICAgLy8gb3IgdGhlIHByb21pc2UgaXMgbm90IGN1cnJlbnRseSBpbiBwZW5kaW5nIHN0YXRlXG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5WQUxVRSA9IHZhbHVlO1xuICAgIHRoaXMuU1RBVEUgPSBzdGF0ZTtcblxuICAgIHRoaXMucHJvY2Vzc1JlZ2lzdGVyZWRIYW5kbGVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIGZ1bGZpbGxcbiAgICogQHBhcmFtIHZhbHVlIGFueSB2YWx1ZVxuICAgKi9cbiAgcHVibGljIGZ1bGZpbGwodmFsdWU6IGFueSk6IHZvaWQge1xuICAgIHRoaXMudHJhbnNpdGlvblN0YXRlKFByb21pc2VTdGF0ZS5GVUxGSUxMRUQsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZWplY3RcbiAgICogQHBhcmFtIHJlYXNvbiBjYW4gYnkgYW55dGhpbmcgYnV0IGdlbmVyYWxseSBhbiBpbnN0YW5jZSBvZiBFcnJvciBvYmplY3RcbiAgICovXG4gIHB1YmxpYyByZWplY3QocmVhc29uOiBFcnJvcnxhbnkpOiB2b2lkIHtcbiAgICB0aGlzLnRyYW5zaXRpb25TdGF0ZShQcm9taXNlU3RhdGUuUkVKRUNURUQsIHJlYXNvbik7XG4gIH1cblxuICAvKipcbiAgICogdHJpZXMgdG8gYWRvcHQgc3RhdGUgb2Ygc3VwcGxpZWQgcHJvbWlzZVxuICAgKiBAcGFyYW0geCBQcm9taXNlIG9iamVjdCwgd2hvc2Ugc3RhdGUgdGhlIGN1cnJlbnQgcHJvbWlzZSBpbnN0YW5jZSB3aWxsIGFkb3B0XG4gICAqL1xuICBwdWJsaWMgYWRvcHRTdGF0ZU9mKHg6IE15UHJvbWlzZSkge1xuICAgIHRoaXMudHJhbnNpdGlvblN0YXRlKHguc3RhdGUsIHgudmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBwcm9jZXNzUmVnaXN0ZXJlZEhhbmRsZXJzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLlNUQVRFICE9PSBQcm9taXNlU3RhdGUuUEVORElORykge1xuICAgICAgLy8gMi4yLjQgb25GdWxmaWxsZWQgb3Igb25SZWplY3RlZCBtdXN0IG5vdCBiZSBjYWxsZWRcbiAgICAgIC8vIHVudGlsIHRoZSBleGVjdXRpb24gY29udGV4dCBzdGFjayBjb250YWlucyBvbmx5IHBsYXRmb3JtIGNvZGUuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAvLyAyLjIuNy4gdGhlbiBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIHByb21pc2UuXG4gICAgICAgIC8vICAgMi4yLjYuMS4gSWYvd2hlbiBwcm9taXNlIGlzIGZ1bGZpbGxlZCxcbiAgICAgICAgLy8gICAgIGFsbCByZXNwZWN0aXZlIG9uRnVsZmlsbGVkIGNhbGxiYWNrcyBtdXN0IGV4ZWN1dGUgaW4gdGhlXG4gICAgICAgIC8vICAgICBvcmRlciBvZiB0aGVpciBvcmlnaW5hdGluZyBjYWxscyB0byB0aGVuLlxuICAgICAgICAvLyAgIDIuMi42LjIuIElmL3doZW4gcHJvbWlzZSBpcyByZWplY3RlZCxcbiAgICAgICAgLy8gICAgIGFsbCByZXNwZWN0aXZlIG9uUmVqZWN0ZWQgY2FsbGJhY2tzIG11c3QgZXhlY3V0ZSBpbiB0aGVcbiAgICAgICAgLy8gICAgIG9yZGVyIG9mIHRoZWlyIG9yaWdpbmF0aW5nIGNhbGxzIHRvIHRoZW4uXG4gICAgICAgIC8vIHRoaXMgaXMgYWNoZWl2ZWQgYnkgZGVxdWV1ZSBvbiBGSUZPIGRhdGEgc3RydWN0dXJlIChpLmUuIHF1ZXVlKVxuICAgICAgICB3aGlsZSAodGhpcy5wcm9taXNlU2V0dGxlbWVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGRlcXVldWVcbiAgICAgICAgICBjb25zdCBwcm9taXNlOiBNeVByb21pc2V8YW55ID0gdGhpcy5wcm9taXNlU2V0dGxlbWVudFF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gMi4yLjUuIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIG11c3QgYmUgY2FsbGVkIGFzIGZ1bmN0aW9ucyAoaS5lLiB3aXRoIG5vIHRoaXMgdmFsdWUpLlxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoXG4gICAgICAgICAgICAgIHRoaXMuU1RBVEUgPT09IFByb21pc2VTdGF0ZS5GVUxGSUxMRUQgPyBwcm9taXNlLm9uRnVsZmlsbGVkIDogcHJvbWlzZS5vblJlamVjdGVkXG4gICAgICAgICAgICApKHRoaXMuVkFMVUUpO1xuICAgICAgICAgICAgLy8gMi4yLjcuMS4gSWYgZWl0aGVyIG9uRnVsZmlsbGVkIG9yIG9uUmVqZWN0ZWQgcmV0dXJucyBhIHZhbHVlIHgsXG4gICAgICAgICAgICAvLyBydW4gdGhlIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmUgW1tSZXNvbHZlXV0ocHJvbWlzZTIsIHgpLlxuICAgICAgICAgICAgUHJvbWlzZVJlc29sdXRpb25Qcm9jZWR1cmUucmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gMi4yLjcuMi4gSWYgZWl0aGVyIG9uRnVsZmlsbGVkIG9yIG9uUmVqZWN0ZWQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBlLFxuICAgICAgICAgICAgLy8gcHJvbWlzZTIgbXVzdCBiZSByZWplY3RlZCB3aXRoIGUgYXMgdGhlIHJlYXNvbi5cbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG59XG4iXX0=