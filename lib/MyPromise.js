"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _PromiseResolutionProcedure = _interopRequireDefault(require("./PromiseResolutionProcedure"));

var _PromiseState = require("./PromiseState");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// 1.1. “promise” is an object or function with a then method whose behavior conforms to the Promises/A+ specification.
var MyPromise =
/*#__PURE__*/
function () {
  _createClass(MyPromise, [{
    key: "state",
    // instance variables
    // getters & setters
    get: function get() {
      return this.STATE;
    }
  }]);

  function MyPromise() {
    var _this = this;

    var executor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, MyPromise);

    _defineProperty(this, "value", void 0);

    _defineProperty(this, "STATE", void 0);

    _defineProperty(this, "onFulfilledHandler", void 0);

    _defineProperty(this, "onRejectedHandler", void 0);

    _defineProperty(this, "promiseSettlementQueue", void 0);

    this.value = null; // default promise value as null

    this.STATE = _PromiseState.PromiseState.PENDING; // default promise state as pending
    // register default handlers for promise on fulfillment and rejection

    this.onFulfilledHandler = function (value) {
      return value;
    };

    this.onRejectedHandler = function (reason) {
      throw reason;
    }; // create an empty promise settlement queue for promises generated by then calls


    this.promiseSettlementQueue = []; // bind executor resolve reject callbacks

    if (executor) {
      executor(function (value) {
        _PromiseResolutionProcedure.default.resolve(_this, value);
      }, function (reason) {
        _this.reject(reason);
      });
    }
  }
  /**
   * 2.2.1 Both onFulfilled and onRejected are optional arguments:
   *
   * @param onFulfilled
   * @param onRejected
   */


  _createClass(MyPromise, [{
    key: "then",
    value: function then(onFulfilled, onRejected) {
      // create a new promise to be returned by then for promise chaining
      var promise = new MyPromise(); // 2.2.1.1 If onFulfilled is not a function, it must be ignored.

      if (typeof onFulfilled === "function") {
        promise.onFulfilledHandler = onFulfilled;
      } // 2.2.1.2 If onRejected is not a function, it must be ignored.


      if (typeof onRejected === "function") {
        promise.onFulfilledHandler = onRejected;
      }
      /**
       * 2.2.6. then may be called multiple times on the same promise.
       *   2.2.6.1. If/when promise is fulfilled, all respective onFulfilled
       *     callbacks must execute in the order of their originating calls to then.
       *   2.2.6.2. If/when promise is rejected, all respective onRejected
       *     callbacks must execute in the order of their originating calls to then.
       */


      this.promiseSettlementQueue.push(promise);
      this.processRegisteredHandlers(); // 2.2.7. then must return a promise

      return promise;
    }
    /**
     * 2.1.1. When pending, a promise:
     *   2.1.1.1. may transition to either the fulfilled or rejected state.
     * 2.1.2. When fulfilled, a promise:
     *   2.1.2.1. must not transition to any other state.
     *   2.1.2.2. must have a value, which must not change.
     * 2.1.3. When rejected, a promise:
     *   2.1.3.1. must not transition to any other state.
     *   2.1.3.2. must have a reason, which must not change.
     *
     * @param state state to transition to
     * @param value value passed with the transition for
     */

  }, {
    key: "transitionState",
    value: function transitionState(state, value) {
      if (this.STATE === state || this.STATE !== _PromiseState.PromiseState.PENDING) {
        // if the current state is same as the state being transitioned to
        // or the promise is not currently in pending state
        // do nothing
        return;
      }

      this.value = value;
      this.STATE = state;
      this.processRegisteredHandlers();
    }
    /**
     * fulfill
     * @param value any value
     */

  }, {
    key: "fulfill",
    value: function fulfill(value) {
      this.transitionState(_PromiseState.PromiseState.FULFILLED, value);
    }
    /**
     * reject
     * @param reason can by anything but generally an instance of Error object
     */

  }, {
    key: "reject",
    value: function reject(reason) {
      this.transitionState(_PromiseState.PromiseState.REJECTED, reason);
    }
    /**
     * tries to adopt state of supplied promise
     * @param x Promise object, whose state the current promise instance will adopt
     */

  }, {
    key: "adoptStateOf",
    value: function adoptStateOf(x) {
      this.transitionState(x.state, x.value);
    }
  }, {
    key: "processRegisteredHandlers",
    value: function processRegisteredHandlers() {
      var _this2 = this;

      if (this.STATE !== _PromiseState.PromiseState.PENDING) {
        // 2.2.4 onFulfilled or onRejected must not be called
        // until the execution context stack contains only platform code.
        setTimeout(function () {
          // 2.2.7. then may be called multiple times on the same promise.
          //   2.2.6.1. If/when promise is fulfilled,
          //     all respective onFulfilled callbacks must execute in the
          //     order of their originating calls to then.
          //   2.2.6.2. If/when promise is rejected,
          //     all respective onRejected callbacks must execute in the
          //     order of their originating calls to then.
          // this is acheived by dequeue on FIFO data structure (i.e. queue)
          while (_this2.promiseSettlementQueue.length) {
            // dequeue
            var promise = _this2.promiseSettlementQueue.shift();

            try {
              // 2.2.5. onFulfilled and onRejected must be called as functions (i.e. with no this value).
              var value = (_this2.STATE === _PromiseState.PromiseState.FULFILLED ? promise.onFulfilled : promise.onRejected)(_this2.value); // 2.2.7.1. If either onFulfilled or onRejected returns a value x,
              // run the Promise Resolution Procedure [[Resolve]](promise2, x).

              _PromiseResolutionProcedure.default.resolve(promise, value);
            } catch (e) {
              // 2.2.7.2. If either onFulfilled or onRejected throws an exception e,
              // promise2 must be rejected with e as the reason.
              promise.reject(e);
            }
          }
        }, 0);
      }
    }
  }]);

  return MyPromise;
}();

exports.default = MyPromise;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NeVByb21pc2UudHMiXSwibmFtZXMiOlsiTXlQcm9taXNlIiwiU1RBVEUiLCJleGVjdXRvciIsInZhbHVlIiwiUHJvbWlzZVN0YXRlIiwiUEVORElORyIsIm9uRnVsZmlsbGVkSGFuZGxlciIsIm9uUmVqZWN0ZWRIYW5kbGVyIiwicmVhc29uIiwicHJvbWlzZVNldHRsZW1lbnRRdWV1ZSIsIlByb21pc2VSZXNvbHV0aW9uUHJvY2VkdXJlIiwicmVzb2x2ZSIsInJlamVjdCIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsInByb21pc2UiLCJwdXNoIiwicHJvY2Vzc1JlZ2lzdGVyZWRIYW5kbGVycyIsInN0YXRlIiwidHJhbnNpdGlvblN0YXRlIiwiRlVMRklMTEVEIiwiUkVKRUNURUQiLCJ4Iiwic2V0VGltZW91dCIsImxlbmd0aCIsInNoaWZ0IiwiZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7QUFFQTs7QUFDQTs7Ozs7Ozs7Ozs7O0FBR0E7SUFDcUJBLFM7Ozs7O0FBRW5CO0FBVUE7d0JBRTBCO0FBQ3hCLGFBQU8sS0FBS0MsS0FBWjtBQUNEOzs7QUFFRCx1QkFBbUQ7QUFBQTs7QUFBQSxRQUF2Q0MsUUFBdUMsdUVBQU4sSUFBTTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFDakQsU0FBS0MsS0FBTCxHQUFhLElBQWIsQ0FEaUQsQ0FDOUI7O0FBQ25CLFNBQUtGLEtBQUwsR0FBYUcsMkJBQWFDLE9BQTFCLENBRmlELENBRWQ7QUFFbkM7O0FBQ0EsU0FBS0Msa0JBQUwsR0FBMEIsVUFBQ0gsS0FBRDtBQUFBLGFBQWdCQSxLQUFoQjtBQUFBLEtBQTFCOztBQUNBLFNBQUtJLGlCQUFMLEdBQXlCLFVBQUNDLE1BQUQsRUFBdUI7QUFBRSxZQUFNQSxNQUFOO0FBQWUsS0FBakUsQ0FOaUQsQ0FRakQ7OztBQUNBLFNBQUtDLHNCQUFMLEdBQThCLEVBQTlCLENBVGlELENBV2pEOztBQUNBLFFBQUlQLFFBQUosRUFBYztBQUNaQSxNQUFBQSxRQUFRLENBQUMsVUFBQ0MsS0FBRCxFQUFnQjtBQUN2Qk8sNENBQTJCQyxPQUEzQixDQUFtQyxLQUFuQyxFQUF5Q1IsS0FBekM7QUFDRCxPQUZPLEVBRUwsVUFBQ0ssTUFBRCxFQUFpQjtBQUNsQixRQUFBLEtBQUksQ0FBQ0ksTUFBTCxDQUFZSixNQUFaO0FBQ0QsT0FKTyxDQUFSO0FBS0Q7QUFDRjtBQUVEOzs7Ozs7Ozs7O3lCQU1ZSyxXLEVBQWtCQyxVLEVBQTRCO0FBQ3hEO0FBQ0EsVUFBTUMsT0FBa0IsR0FBRyxJQUFJZixTQUFKLEVBQTNCLENBRndELENBSXhEOztBQUNBLFVBQUksT0FBT2EsV0FBUCxLQUF1QixVQUEzQixFQUF1QztBQUNyQ0UsUUFBQUEsT0FBTyxDQUFDVCxrQkFBUixHQUE2Qk8sV0FBN0I7QUFDRCxPQVB1RCxDQVN4RDs7O0FBQ0EsVUFBSSxPQUFPQyxVQUFQLEtBQXNCLFVBQTFCLEVBQXNDO0FBQ3BDQyxRQUFBQSxPQUFPLENBQUNULGtCQUFSLEdBQTZCUSxVQUE3QjtBQUNEO0FBRUQ7Ozs7Ozs7OztBQU9BLFdBQUtMLHNCQUFMLENBQTRCTyxJQUE1QixDQUFpQ0QsT0FBakM7QUFDQSxXQUFLRSx5QkFBTCxHQXRCd0QsQ0F3QnhEOztBQUNBLGFBQU9GLE9BQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O29DQWF1QkcsSyxFQUFxQmYsSyxFQUFrQjtBQUU1RCxVQUFJLEtBQUtGLEtBQUwsS0FBZWlCLEtBQWYsSUFBd0IsS0FBS2pCLEtBQUwsS0FBZUcsMkJBQWFDLE9BQXhELEVBQWlFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQsV0FBS0YsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsV0FBS0YsS0FBTCxHQUFhaUIsS0FBYjtBQUVBLFdBQUtELHlCQUFMO0FBQ0Q7QUFFRDs7Ozs7Ozs0QkFJZWQsSyxFQUFrQjtBQUMvQixXQUFLZ0IsZUFBTCxDQUFxQmYsMkJBQWFnQixTQUFsQyxFQUE2Q2pCLEtBQTdDO0FBQ0Q7QUFFRDs7Ozs7OzsyQkFJY0ssTSxFQUF5QjtBQUNyQyxXQUFLVyxlQUFMLENBQXFCZiwyQkFBYWlCLFFBQWxDLEVBQTRDYixNQUE1QztBQUNEO0FBRUQ7Ozs7Ozs7aUNBSW9CYyxDLEVBQWM7QUFDaEMsV0FBS0gsZUFBTCxDQUFxQkcsQ0FBQyxDQUFDSixLQUF2QixFQUE4QkksQ0FBQyxDQUFDbkIsS0FBaEM7QUFDRDs7O2dEQUV5QztBQUFBOztBQUN4QyxVQUFJLEtBQUtGLEtBQUwsS0FBZUcsMkJBQWFDLE9BQWhDLEVBQXlDO0FBQ3ZDO0FBQ0E7QUFDQWtCLFFBQUFBLFVBQVUsQ0FBQyxZQUFNO0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFPLE1BQUksQ0FBQ2Qsc0JBQUwsQ0FBNEJlLE1BQW5DLEVBQTJDO0FBQ3pDO0FBQ0EsZ0JBQU1ULE9BQXNCLEdBQUcsTUFBSSxDQUFDTixzQkFBTCxDQUE0QmdCLEtBQTVCLEVBQS9COztBQUVBLGdCQUFJO0FBQ0Y7QUFDQSxrQkFBTXRCLEtBQUssR0FBRyxDQUNaLE1BQUksQ0FBQ0YsS0FBTCxLQUFlRywyQkFBYWdCLFNBQTVCLEdBQXdDTCxPQUFPLENBQUNGLFdBQWhELEdBQThERSxPQUFPLENBQUNELFVBRDFELEVBRVosTUFBSSxDQUFDWCxLQUZPLENBQWQsQ0FGRSxDQUtGO0FBQ0E7O0FBQ0FPLGtEQUEyQkMsT0FBM0IsQ0FBbUNJLE9BQW5DLEVBQTRDWixLQUE1QztBQUNELGFBUkQsQ0FRRSxPQUFPdUIsQ0FBUCxFQUFVO0FBQ1Y7QUFDQTtBQUNBWCxjQUFBQSxPQUFPLENBQUNILE1BQVIsQ0FBZWMsQ0FBZjtBQUNEO0FBQ0Y7QUFDRixTQTVCUyxFQTRCUCxDQTVCTyxDQUFWO0FBNkJEO0FBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IFByb21pc2VSZXNvbHV0aW9uUHJvY2VkdXJlIGZyb20gXCIuL1Byb21pc2VSZXNvbHV0aW9uUHJvY2VkdXJlXCI7XG5pbXBvcnQgeyBQcm9taXNlU3RhdGUgfSBmcm9tIFwiLi9Qcm9taXNlU3RhdGVcIjtcbmltcG9ydCBUaGVuYWJsZSBmcm9tIFwiLi9UaGVuYWJsZVwiO1xuXG4vLyAxLjEuIOKAnHByb21pc2XigJ0gaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHdpdGggYSB0aGVuIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGUgUHJvbWlzZXMvQSsgc3BlY2lmaWNhdGlvbi5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UHJvbWlzZSBpbXBsZW1lbnRzIFRoZW5hYmxlIHtcblxuICAvLyBpbnN0YW5jZSB2YXJpYWJsZXNcblxuICBwcml2YXRlIHZhbHVlOiBhbnk7XG4gIHByaXZhdGUgU1RBVEU6IFByb21pc2VTdGF0ZTtcblxuICBwcml2YXRlIG9uRnVsZmlsbGVkSGFuZGxlcjogQ2FsbGFibGVGdW5jdGlvbjtcbiAgcHJpdmF0ZSBvblJlamVjdGVkSGFuZGxlcjogQ2FsbGFibGVGdW5jdGlvbjtcblxuICBwcml2YXRlIHByb21pc2VTZXR0bGVtZW50UXVldWU6IE15UHJvbWlzZVtdO1xuXG4gIC8vIGdldHRlcnMgJiBzZXR0ZXJzXG5cbiAgZ2V0IHN0YXRlKCk6IFByb21pc2VTdGF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuU1RBVEU7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihleGVjdXRvcjogQ2FsbGFibGVGdW5jdGlvbnxhbnkgPSBudWxsKSB7XG4gICAgdGhpcy52YWx1ZSA9IG51bGw7IC8vIGRlZmF1bHQgcHJvbWlzZSB2YWx1ZSBhcyBudWxsXG4gICAgdGhpcy5TVEFURSA9IFByb21pc2VTdGF0ZS5QRU5ESU5HOyAvLyBkZWZhdWx0IHByb21pc2Ugc3RhdGUgYXMgcGVuZGluZ1xuXG4gICAgLy8gcmVnaXN0ZXIgZGVmYXVsdCBoYW5kbGVycyBmb3IgcHJvbWlzZSBvbiBmdWxmaWxsbWVudCBhbmQgcmVqZWN0aW9uXG4gICAgdGhpcy5vbkZ1bGZpbGxlZEhhbmRsZXIgPSAodmFsdWU6IGFueSkgPT4gdmFsdWU7XG4gICAgdGhpcy5vblJlamVjdGVkSGFuZGxlciA9IChyZWFzb246IEVycm9yfGFueSkgPT4geyB0aHJvdyByZWFzb247IH07XG5cbiAgICAvLyBjcmVhdGUgYW4gZW1wdHkgcHJvbWlzZSBzZXR0bGVtZW50IHF1ZXVlIGZvciBwcm9taXNlcyBnZW5lcmF0ZWQgYnkgdGhlbiBjYWxsc1xuICAgIHRoaXMucHJvbWlzZVNldHRsZW1lbnRRdWV1ZSA9IFtdO1xuXG4gICAgLy8gYmluZCBleGVjdXRvciByZXNvbHZlIHJlamVjdCBjYWxsYmFja3NcbiAgICBpZiAoZXhlY3V0b3IpIHtcbiAgICAgIGV4ZWN1dG9yKCh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgIFByb21pc2VSZXNvbHV0aW9uUHJvY2VkdXJlLnJlc29sdmUodGhpcywgdmFsdWUpO1xuICAgICAgfSwgKHJlYXNvbjogYW55KSA9PiB7XG4gICAgICAgIHRoaXMucmVqZWN0KHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogMi4yLjEgQm90aCBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb3B0aW9uYWwgYXJndW1lbnRzOlxuICAgKlxuICAgKiBAcGFyYW0gb25GdWxmaWxsZWRcbiAgICogQHBhcmFtIG9uUmVqZWN0ZWRcbiAgICovXG4gIHB1YmxpYyB0aGVuKG9uRnVsZmlsbGVkOiBhbnksIG9uUmVqZWN0ZWQ6IGFueSk6IE15UHJvbWlzZSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IHByb21pc2UgdG8gYmUgcmV0dXJuZWQgYnkgdGhlbiBmb3IgcHJvbWlzZSBjaGFpbmluZ1xuICAgIGNvbnN0IHByb21pc2U6IE15UHJvbWlzZSA9IG5ldyBNeVByb21pc2UoKTtcblxuICAgIC8vIDIuMi4xLjEgSWYgb25GdWxmaWxsZWQgaXMgbm90IGEgZnVuY3Rpb24sIGl0IG11c3QgYmUgaWdub3JlZC5cbiAgICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHByb21pc2Uub25GdWxmaWxsZWRIYW5kbGVyID0gb25GdWxmaWxsZWQ7XG4gICAgfVxuXG4gICAgLy8gMi4yLjEuMiBJZiBvblJlamVjdGVkIGlzIG5vdCBhIGZ1bmN0aW9uLCBpdCBtdXN0IGJlIGlnbm9yZWQuXG4gICAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHByb21pc2Uub25GdWxmaWxsZWRIYW5kbGVyID0gb25SZWplY3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAyLjIuNi4gdGhlbiBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIHByb21pc2UuXG4gICAgICogICAyLjIuNi4xLiBJZi93aGVuIHByb21pc2UgaXMgZnVsZmlsbGVkLCBhbGwgcmVzcGVjdGl2ZSBvbkZ1bGZpbGxlZFxuICAgICAqICAgICBjYWxsYmFja3MgbXVzdCBleGVjdXRlIGluIHRoZSBvcmRlciBvZiB0aGVpciBvcmlnaW5hdGluZyBjYWxscyB0byB0aGVuLlxuICAgICAqICAgMi4yLjYuMi4gSWYvd2hlbiBwcm9taXNlIGlzIHJlamVjdGVkLCBhbGwgcmVzcGVjdGl2ZSBvblJlamVjdGVkXG4gICAgICogICAgIGNhbGxiYWNrcyBtdXN0IGV4ZWN1dGUgaW4gdGhlIG9yZGVyIG9mIHRoZWlyIG9yaWdpbmF0aW5nIGNhbGxzIHRvIHRoZW4uXG4gICAgICovXG4gICAgdGhpcy5wcm9taXNlU2V0dGxlbWVudFF1ZXVlLnB1c2gocHJvbWlzZSk7XG4gICAgdGhpcy5wcm9jZXNzUmVnaXN0ZXJlZEhhbmRsZXJzKCk7XG5cbiAgICAvLyAyLjIuNy4gdGhlbiBtdXN0IHJldHVybiBhIHByb21pc2VcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiAyLjEuMS4gV2hlbiBwZW5kaW5nLCBhIHByb21pc2U6XG4gICAqICAgMi4xLjEuMS4gbWF5IHRyYW5zaXRpb24gdG8gZWl0aGVyIHRoZSBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQgc3RhdGUuXG4gICAqIDIuMS4yLiBXaGVuIGZ1bGZpbGxlZCwgYSBwcm9taXNlOlxuICAgKiAgIDIuMS4yLjEuIG11c3Qgbm90IHRyYW5zaXRpb24gdG8gYW55IG90aGVyIHN0YXRlLlxuICAgKiAgIDIuMS4yLjIuIG11c3QgaGF2ZSBhIHZhbHVlLCB3aGljaCBtdXN0IG5vdCBjaGFuZ2UuXG4gICAqIDIuMS4zLiBXaGVuIHJlamVjdGVkLCBhIHByb21pc2U6XG4gICAqICAgMi4xLjMuMS4gbXVzdCBub3QgdHJhbnNpdGlvbiB0byBhbnkgb3RoZXIgc3RhdGUuXG4gICAqICAgMi4xLjMuMi4gbXVzdCBoYXZlIGEgcmVhc29uLCB3aGljaCBtdXN0IG5vdCBjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvXG4gICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSBwYXNzZWQgd2l0aCB0aGUgdHJhbnNpdGlvbiBmb3JcbiAgICovXG4gIHB1YmxpYyB0cmFuc2l0aW9uU3RhdGUoc3RhdGU6IFByb21pc2VTdGF0ZSwgdmFsdWU6IGFueSk6IHZvaWQge1xuXG4gICAgaWYgKHRoaXMuU1RBVEUgPT09IHN0YXRlIHx8IHRoaXMuU1RBVEUgIT09IFByb21pc2VTdGF0ZS5QRU5ESU5HKSB7XG4gICAgICAvLyBpZiB0aGUgY3VycmVudCBzdGF0ZSBpcyBzYW1lIGFzIHRoZSBzdGF0ZSBiZWluZyB0cmFuc2l0aW9uZWQgdG9cbiAgICAgIC8vIG9yIHRoZSBwcm9taXNlIGlzIG5vdCBjdXJyZW50bHkgaW4gcGVuZGluZyBzdGF0ZVxuICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLlNUQVRFID0gc3RhdGU7XG5cbiAgICB0aGlzLnByb2Nlc3NSZWdpc3RlcmVkSGFuZGxlcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmdWxmaWxsXG4gICAqIEBwYXJhbSB2YWx1ZSBhbnkgdmFsdWVcbiAgICovXG4gIHB1YmxpYyBmdWxmaWxsKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLnRyYW5zaXRpb25TdGF0ZShQcm9taXNlU3RhdGUuRlVMRklMTEVELCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogcmVqZWN0XG4gICAqIEBwYXJhbSByZWFzb24gY2FuIGJ5IGFueXRoaW5nIGJ1dCBnZW5lcmFsbHkgYW4gaW5zdGFuY2Ugb2YgRXJyb3Igb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgcmVqZWN0KHJlYXNvbjogRXJyb3J8YW55KTogdm9pZCB7XG4gICAgdGhpcy50cmFuc2l0aW9uU3RhdGUoUHJvbWlzZVN0YXRlLlJFSkVDVEVELCByZWFzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIHRyaWVzIHRvIGFkb3B0IHN0YXRlIG9mIHN1cHBsaWVkIHByb21pc2VcbiAgICogQHBhcmFtIHggUHJvbWlzZSBvYmplY3QsIHdob3NlIHN0YXRlIHRoZSBjdXJyZW50IHByb21pc2UgaW5zdGFuY2Ugd2lsbCBhZG9wdFxuICAgKi9cbiAgcHVibGljIGFkb3B0U3RhdGVPZih4OiBNeVByb21pc2UpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25TdGF0ZSh4LnN0YXRlLCB4LnZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgcHJvY2Vzc1JlZ2lzdGVyZWRIYW5kbGVycygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5TVEFURSAhPT0gUHJvbWlzZVN0YXRlLlBFTkRJTkcpIHtcbiAgICAgIC8vIDIuMi40IG9uRnVsZmlsbGVkIG9yIG9uUmVqZWN0ZWQgbXVzdCBub3QgYmUgY2FsbGVkXG4gICAgICAvLyB1bnRpbCB0aGUgZXhlY3V0aW9uIGNvbnRleHQgc3RhY2sgY29udGFpbnMgb25seSBwbGF0Zm9ybSBjb2RlLlxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG5cbiAgICAgICAgLy8gMi4yLjcuIHRoZW4gbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZSBwcm9taXNlLlxuICAgICAgICAvLyAgIDIuMi42LjEuIElmL3doZW4gcHJvbWlzZSBpcyBmdWxmaWxsZWQsXG4gICAgICAgIC8vICAgICBhbGwgcmVzcGVjdGl2ZSBvbkZ1bGZpbGxlZCBjYWxsYmFja3MgbXVzdCBleGVjdXRlIGluIHRoZVxuICAgICAgICAvLyAgICAgb3JkZXIgb2YgdGhlaXIgb3JpZ2luYXRpbmcgY2FsbHMgdG8gdGhlbi5cbiAgICAgICAgLy8gICAyLjIuNi4yLiBJZi93aGVuIHByb21pc2UgaXMgcmVqZWN0ZWQsXG4gICAgICAgIC8vICAgICBhbGwgcmVzcGVjdGl2ZSBvblJlamVjdGVkIGNhbGxiYWNrcyBtdXN0IGV4ZWN1dGUgaW4gdGhlXG4gICAgICAgIC8vICAgICBvcmRlciBvZiB0aGVpciBvcmlnaW5hdGluZyBjYWxscyB0byB0aGVuLlxuICAgICAgICAvLyB0aGlzIGlzIGFjaGVpdmVkIGJ5IGRlcXVldWUgb24gRklGTyBkYXRhIHN0cnVjdHVyZSAoaS5lLiBxdWV1ZSlcbiAgICAgICAgd2hpbGUgKHRoaXMucHJvbWlzZVNldHRsZW1lbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBkZXF1ZXVlXG4gICAgICAgICAgY29uc3QgcHJvbWlzZTogTXlQcm9taXNlfGFueSA9IHRoaXMucHJvbWlzZVNldHRsZW1lbnRRdWV1ZS5zaGlmdCgpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIDIuMi41LiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBtdXN0IGJlIGNhbGxlZCBhcyBmdW5jdGlvbnMgKGkuZS4gd2l0aCBubyB0aGlzIHZhbHVlKS5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKFxuICAgICAgICAgICAgICB0aGlzLlNUQVRFID09PSBQcm9taXNlU3RhdGUuRlVMRklMTEVEID8gcHJvbWlzZS5vbkZ1bGZpbGxlZCA6IHByb21pc2Uub25SZWplY3RlZFxuICAgICAgICAgICAgKSh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIC8vIDIuMi43LjEuIElmIGVpdGhlciBvbkZ1bGZpbGxlZCBvciBvblJlamVjdGVkIHJldHVybnMgYSB2YWx1ZSB4LFxuICAgICAgICAgICAgLy8gcnVuIHRoZSBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlIFtbUmVzb2x2ZV1dKHByb21pc2UyLCB4KS5cbiAgICAgICAgICAgIFByb21pc2VSZXNvbHV0aW9uUHJvY2VkdXJlLnJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIDIuMi43LjIuIElmIGVpdGhlciBvbkZ1bGZpbGxlZCBvciBvblJlamVjdGVkIHRocm93cyBhbiBleGNlcHRpb24gZSxcbiAgICAgICAgICAgIC8vIHByb21pc2UyIG11c3QgYmUgcmVqZWN0ZWQgd2l0aCBlIGFzIHRoZSByZWFzb24uXG4gICAgICAgICAgICBwcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgfVxufVxuIl19