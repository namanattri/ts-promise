"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _PromiseState = require("./PromiseState");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// 1.1. “promise” is an object or function with a then method whose behavior conforms to the Promises/A+ specification.
var MyPromise =
/*#__PURE__*/
function () {
  function MyPromise() {
    var executor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    _classCallCheck(this, MyPromise);

    _defineProperty(this, "value", void 0);

    _defineProperty(this, "state", void 0);

    _defineProperty(this, "onFulfilledHandler", void 0);

    _defineProperty(this, "onRejectedHandler", void 0);

    _defineProperty(this, "promiseSettlementQueue", void 0);

    this.value = null; // default promise value as null

    this.state = _PromiseState.PromiseState.PENDING; // default promise state as pending
    // register default handlers for promise on fulfillment and rejection

    this.onFulfilledHandler = function (value) {
      return value;
    };

    this.onRejectedHandler = function (reason) {
      throw reason;
    }; // create an empty promise settlement queue for promises generated by then calls


    this.promiseSettlementQueue = []; // bind executor resolve reject callbacks

    if (executor) {
      executor(function (value) {
        /** @todo Promise Resolution Procedure */
      }, function (reason) {
        /** @todo Promise Rejection Procedure */
      });
    }
  }
  /**
   * 2.2.1 Both onFulfilled and onRejected are optional arguments:
   *
   * @param onFulfilled
   * @param onRejected
   */


  _createClass(MyPromise, [{
    key: "then",
    value: function then(onFulfilled, onRejected) {
      // create a new promise to be returned by then for promise chaining
      var promise = new MyPromise(); // 2.2.1.1 If onFulfilled is not a function, it must be ignored.

      if (typeof onFulfilled === "function") {
        promise.onFulfilledHandler = onFulfilled;
      } // 2.2.1.2 If onRejected is not a function, it must be ignored.


      if (typeof onRejected === "function") {
        promise.onFulfilledHandler = onRejected;
      }

      this.promiseSettlementQueue.push(promise);
      /** @todo process promise */

      return promise;
    }
    /**
     * 2.1.1. When pending, a promise:
     *   2.1.1.1. may transition to either the fulfilled or rejected state.
     * 2.1.2. When fulfilled, a promise:
     *   2.1.2.1. must not transition to any other state.
     *   2.1.2.2. must have a value, which must not change.
     * 2.1.3. When rejected, a promise:
     *   2.1.3.1. must not transition to any other state.
     *   2.1.3.2. must have a reason, which must not change.
     *
     * @param state state to transition to
     * @param value value passed with the transition for
     */

  }, {
    key: "transitionState",
    value: function transitionState(state, value) {
      if (this.state === state || this.state !== _PromiseState.PromiseState.PENDING) {
        // if the current state is same as the state being transitioned to
        // or the promise is not currently in pending state
        // do nothing
        return;
      }

      this.value = value;
      this.state = state;
      /** @todo ripple state transition effect: process promise */
    }
  }]);

  return MyPromise;
}();

exports.default = MyPromise;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9NeVByb21pc2UudHMiXSwibmFtZXMiOlsiTXlQcm9taXNlIiwiZXhlY3V0b3IiLCJ2YWx1ZSIsInN0YXRlIiwiUHJvbWlzZVN0YXRlIiwiUEVORElORyIsIm9uRnVsZmlsbGVkSGFuZGxlciIsIm9uUmVqZWN0ZWRIYW5kbGVyIiwicmVhc29uIiwicHJvbWlzZVNldHRsZW1lbnRRdWV1ZSIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsInByb21pc2UiLCJwdXNoIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztBQUVBOzs7Ozs7Ozs7O0FBR0E7SUFDcUJBLFM7OztBQVVuQix1QkFBbUQ7QUFBQSxRQUF2Q0MsUUFBdUMsdUVBQU4sSUFBTTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFDakQsU0FBS0MsS0FBTCxHQUFhLElBQWIsQ0FEaUQsQ0FDOUI7O0FBQ25CLFNBQUtDLEtBQUwsR0FBYUMsMkJBQWFDLE9BQTFCLENBRmlELENBRWQ7QUFFbkM7O0FBQ0EsU0FBS0Msa0JBQUwsR0FBMEIsVUFBQ0osS0FBRDtBQUFBLGFBQWdCQSxLQUFoQjtBQUFBLEtBQTFCOztBQUNBLFNBQUtLLGlCQUFMLEdBQXlCLFVBQUNDLE1BQUQsRUFBdUI7QUFBRSxZQUFNQSxNQUFOO0FBQWUsS0FBakUsQ0FOaUQsQ0FRakQ7OztBQUNBLFNBQUtDLHNCQUFMLEdBQThCLEVBQTlCLENBVGlELENBV2pEOztBQUNBLFFBQUlSLFFBQUosRUFBYztBQUNaQSxNQUFBQSxRQUFRLENBQUMsVUFBQ0MsS0FBRCxFQUFnQjtBQUN2QjtBQUNELE9BRk8sRUFFTCxVQUFDTSxNQUFELEVBQWlCO0FBQ2xCO0FBQ0QsT0FKTyxDQUFSO0FBS0Q7QUFDRjtBQUVEOzs7Ozs7Ozs7O3lCQU1ZRSxXLEVBQWtCQyxVLEVBQTRCO0FBQ3hEO0FBQ0EsVUFBTUMsT0FBa0IsR0FBRyxJQUFJWixTQUFKLEVBQTNCLENBRndELENBSXhEOztBQUNBLFVBQUksT0FBT1UsV0FBUCxLQUF1QixVQUEzQixFQUF1QztBQUNyQ0UsUUFBQUEsT0FBTyxDQUFDTixrQkFBUixHQUE2QkksV0FBN0I7QUFDRCxPQVB1RCxDQVN4RDs7O0FBQ0EsVUFBSSxPQUFPQyxVQUFQLEtBQXNCLFVBQTFCLEVBQXNDO0FBQ3BDQyxRQUFBQSxPQUFPLENBQUNOLGtCQUFSLEdBQTZCSyxVQUE3QjtBQUNEOztBQUVELFdBQUtGLHNCQUFMLENBQTRCSSxJQUE1QixDQUFpQ0QsT0FBakM7QUFDQTs7QUFFQSxhQUFPQSxPQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OztvQ0FhdUJULEssRUFBcUJELEssRUFBa0I7QUFFNUQsVUFBSSxLQUFLQyxLQUFMLEtBQWVBLEtBQWYsSUFBd0IsS0FBS0EsS0FBTCxLQUFlQywyQkFBYUMsT0FBeEQsRUFBaUU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRCxXQUFLSCxLQUFMLEdBQWFBLEtBQWI7QUFDQSxXQUFLQyxLQUFMLEdBQWFBLEtBQWI7QUFFQTtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IFByb21pc2VTdGF0ZSB9IGZyb20gXCIuL1Byb21pc2VTdGF0ZVwiO1xuaW1wb3J0IFRoZW5hYmxlIGZyb20gXCIuL1RoZW5hYmxlXCI7XG5cbi8vIDEuMS4g4oCccHJvbWlzZeKAnSBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIHRoZW4gbWV0aG9kIHdob3NlIGJlaGF2aW9yIGNvbmZvcm1zIHRvIHRoZSBQcm9taXNlcy9BKyBzcGVjaWZpY2F0aW9uLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTXlQcm9taXNlIGltcGxlbWVudHMgVGhlbmFibGUge1xuXG4gIHByaXZhdGUgdmFsdWU6IGFueTtcbiAgcHJpdmF0ZSBzdGF0ZTogUHJvbWlzZVN0YXRlO1xuXG4gIHByaXZhdGUgb25GdWxmaWxsZWRIYW5kbGVyOiBDYWxsYWJsZUZ1bmN0aW9uO1xuICBwcml2YXRlIG9uUmVqZWN0ZWRIYW5kbGVyOiBDYWxsYWJsZUZ1bmN0aW9uO1xuXG4gIHByaXZhdGUgcHJvbWlzZVNldHRsZW1lbnRRdWV1ZTogTXlQcm9taXNlW107XG5cbiAgY29uc3RydWN0b3IoZXhlY3V0b3I6IENhbGxhYmxlRnVuY3Rpb258YW55ID0gbnVsbCkge1xuICAgIHRoaXMudmFsdWUgPSBudWxsOyAvLyBkZWZhdWx0IHByb21pc2UgdmFsdWUgYXMgbnVsbFxuICAgIHRoaXMuc3RhdGUgPSBQcm9taXNlU3RhdGUuUEVORElORzsgLy8gZGVmYXVsdCBwcm9taXNlIHN0YXRlIGFzIHBlbmRpbmdcblxuICAgIC8vIHJlZ2lzdGVyIGRlZmF1bHQgaGFuZGxlcnMgZm9yIHByb21pc2Ugb24gZnVsZmlsbG1lbnQgYW5kIHJlamVjdGlvblxuICAgIHRoaXMub25GdWxmaWxsZWRIYW5kbGVyID0gKHZhbHVlOiBhbnkpID0+IHZhbHVlO1xuICAgIHRoaXMub25SZWplY3RlZEhhbmRsZXIgPSAocmVhc29uOiBFcnJvcnxhbnkpID0+IHsgdGhyb3cgcmVhc29uOyB9O1xuXG4gICAgLy8gY3JlYXRlIGFuIGVtcHR5IHByb21pc2Ugc2V0dGxlbWVudCBxdWV1ZSBmb3IgcHJvbWlzZXMgZ2VuZXJhdGVkIGJ5IHRoZW4gY2FsbHNcbiAgICB0aGlzLnByb21pc2VTZXR0bGVtZW50UXVldWUgPSBbXTtcblxuICAgIC8vIGJpbmQgZXhlY3V0b3IgcmVzb2x2ZSByZWplY3QgY2FsbGJhY2tzXG4gICAgaWYgKGV4ZWN1dG9yKSB7XG4gICAgICBleGVjdXRvcigodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAvKiogQHRvZG8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZSAqL1xuICAgICAgfSwgKHJlYXNvbjogYW55KSA9PiB7XG4gICAgICAgIC8qKiBAdG9kbyBQcm9taXNlIFJlamVjdGlvbiBQcm9jZWR1cmUgKi9cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAyLjIuMSBCb3RoIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvcHRpb25hbCBhcmd1bWVudHM6XG4gICAqXG4gICAqIEBwYXJhbSBvbkZ1bGZpbGxlZFxuICAgKiBAcGFyYW0gb25SZWplY3RlZFxuICAgKi9cbiAgcHVibGljIHRoZW4ob25GdWxmaWxsZWQ6IGFueSwgb25SZWplY3RlZDogYW55KTogTXlQcm9taXNlIHtcbiAgICAvLyBjcmVhdGUgYSBuZXcgcHJvbWlzZSB0byBiZSByZXR1cm5lZCBieSB0aGVuIGZvciBwcm9taXNlIGNoYWluaW5nXG4gICAgY29uc3QgcHJvbWlzZTogTXlQcm9taXNlID0gbmV3IE15UHJvbWlzZSgpO1xuXG4gICAgLy8gMi4yLjEuMSBJZiBvbkZ1bGZpbGxlZCBpcyBub3QgYSBmdW5jdGlvbiwgaXQgbXVzdCBiZSBpZ25vcmVkLlxuICAgIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcHJvbWlzZS5vbkZ1bGZpbGxlZEhhbmRsZXIgPSBvbkZ1bGZpbGxlZDtcbiAgICB9XG5cbiAgICAvLyAyLjIuMS4yIElmIG9uUmVqZWN0ZWQgaXMgbm90IGEgZnVuY3Rpb24sIGl0IG11c3QgYmUgaWdub3JlZC5cbiAgICBpZiAodHlwZW9mIG9uUmVqZWN0ZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcHJvbWlzZS5vbkZ1bGZpbGxlZEhhbmRsZXIgPSBvblJlamVjdGVkO1xuICAgIH1cblxuICAgIHRoaXMucHJvbWlzZVNldHRsZW1lbnRRdWV1ZS5wdXNoKHByb21pc2UpO1xuICAgIC8qKiBAdG9kbyBwcm9jZXNzIHByb21pc2UgKi9cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIDIuMS4xLiBXaGVuIHBlbmRpbmcsIGEgcHJvbWlzZTpcbiAgICogICAyLjEuMS4xLiBtYXkgdHJhbnNpdGlvbiB0byBlaXRoZXIgdGhlIGZ1bGZpbGxlZCBvciByZWplY3RlZCBzdGF0ZS5cbiAgICogMi4xLjIuIFdoZW4gZnVsZmlsbGVkLCBhIHByb21pc2U6XG4gICAqICAgMi4xLjIuMS4gbXVzdCBub3QgdHJhbnNpdGlvbiB0byBhbnkgb3RoZXIgc3RhdGUuXG4gICAqICAgMi4xLjIuMi4gbXVzdCBoYXZlIGEgdmFsdWUsIHdoaWNoIG11c3Qgbm90IGNoYW5nZS5cbiAgICogMi4xLjMuIFdoZW4gcmVqZWN0ZWQsIGEgcHJvbWlzZTpcbiAgICogICAyLjEuMy4xLiBtdXN0IG5vdCB0cmFuc2l0aW9uIHRvIGFueSBvdGhlciBzdGF0ZS5cbiAgICogICAyLjEuMy4yLiBtdXN0IGhhdmUgYSByZWFzb24sIHdoaWNoIG11c3Qgbm90IGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG9cbiAgICogQHBhcmFtIHZhbHVlIHZhbHVlIHBhc3NlZCB3aXRoIHRoZSB0cmFuc2l0aW9uIGZvclxuICAgKi9cbiAgcHVibGljIHRyYW5zaXRpb25TdGF0ZShzdGF0ZTogUHJvbWlzZVN0YXRlLCB2YWx1ZTogYW55KTogdm9pZCB7XG5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gc3RhdGUgfHwgdGhpcy5zdGF0ZSAhPT0gUHJvbWlzZVN0YXRlLlBFTkRJTkcpIHtcbiAgICAgIC8vIGlmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHNhbWUgYXMgdGhlIHN0YXRlIGJlaW5nIHRyYW5zaXRpb25lZCB0b1xuICAgICAgLy8gb3IgdGhlIHByb21pc2UgaXMgbm90IGN1cnJlbnRseSBpbiBwZW5kaW5nIHN0YXRlXG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAgIC8qKiBAdG9kbyByaXBwbGUgc3RhdGUgdHJhbnNpdGlvbiBlZmZlY3Q6IHByb2Nlc3MgcHJvbWlzZSAqL1xuICB9XG5cbn1cbiJdfQ==